/* gclip_select.c generated by valac 0.12.0, the Vala compiler
 * generated from gclip_select.vala, do not modify */

/*
Copyright 2011 Li-Cheng (Andy) Tai
                      atai@atai.org
                      
gclip_select is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

gclip_select is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
gclip_select. If not, see http://www.gnu.org/licenses/.


*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <pango/pango.h>
#include <gdk/gdk.h>

typedef struct _Block1Data Block1Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block2Data Block2Data;

struct _Block1Data {
	int _ref_count_;
	GtkListStore* list_model;
	GtkTreeSelection* selection;
};

struct _Block2Data {
	int _ref_count_;
	GtkScrolledWindow* list_view;
	GtkTreeView* list_box;
	gchar* content;
};


extern gboolean self_set;
gboolean self_set = FALSE;
extern gboolean new_insert;
gboolean new_insert = FALSE;
extern GtkClipboard* clip;
GtkClipboard* clip = NULL;
extern GeeHashMap* content_table;
GeeHashMap* content_table = NULL;
extern GtkButton* delete_button;
GtkButton* delete_button = NULL;
extern GtkButton* delete_all_button;
GtkButton* delete_all_button = NULL;

void setup_list_box (GtkTreeView* list_box);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
static void _lambda0_ (Block1Data* _data1_);
static void __lambda0__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
void add_entry_to_list_box (GtkTreeView* list_box, const gchar* content);
void delete_current_selection (GtkTreeView* list_box);
static gboolean _gtk_tree_iter_equal (const GtkTreeIter* s1, const GtkTreeIter* s2);
void delete_all_selection (GtkTreeView* list_box);
gint _vala_main (gchar** args, int args_length1);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (Block2Data* _data2_);
static GtkTreeIter* _gtk_tree_iter_dup (GtkTreeIter* self);
static void _lambda1_ (Block2Data* _data2_);
static void __lambda1__gtk_button_released (GtkButton* _sender, gpointer self);
static void _lambda2_ (Block2Data* _data2_);
static void __lambda2__gtk_button_released (GtkButton* _sender, gpointer self);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
static void _lambda3_ (GdkEvent* e, Block2Data* _data2_);
static void __lambda3__gtk_clipboard_owner_change (GtkClipboard* _sender, GdkEvent* p0, gpointer self);
static void _lambda4_ (GdkRectangle* rect, Block2Data* _data2_);
static void __lambda4__gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self);


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->selection);
		_g_object_unref0 (_data1_->list_model);
		g_slice_free (Block1Data, _data1_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _lambda0_ (Block1Data* _data1_) {
	GtkTreeIter iter = {0};
	GtkTreeModel* model = NULL;
	gchar* content = NULL;
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	GtkTreeModel* _tmp3_;
	_tmp2_ = gtk_tree_selection_get_selected (_data1_->selection, &_tmp0_, &_tmp1_);
	_g_object_unref0 (model);
	_tmp3_ = _g_object_ref0 (_tmp0_);
	model = _tmp3_;
	iter = _tmp1_;
	if (_tmp2_) {
		gtk_tree_model_get ((GtkTreeModel*) _data1_->list_model, &iter, 0, &content, -1, -1);
		gtk_clipboard_set_text (clip, content, -1);
		self_set = TRUE;
		gtk_widget_set_sensitive ((GtkWidget*) delete_button, TRUE);
	} else {
		gtk_widget_set_sensitive ((GtkWidget*) delete_button, FALSE);
	}
	_g_free0 (content);
	_g_object_unref0 (model);
}


static void __lambda0__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	_lambda0_ (self);
}


void setup_list_box (GtkTreeView* list_box) {
	Block1Data* _data1_;
	GtkListStore* _tmp0_ = NULL;
	GtkCellRendererText* _tmp1_ = NULL;
	GtkCellRendererText* text_renderer;
	GtkTreeSelection* _tmp2_ = NULL;
	GtkTreeSelection* _tmp3_;
	g_return_if_fail (list_box != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = gtk_list_store_new (1, G_TYPE_STRING);
	_data1_->list_model = _tmp0_;
	gtk_tree_view_set_rules_hint (list_box, TRUE);
	gtk_tree_view_set_model (list_box, (GtkTreeModel*) _data1_->list_model);
	_tmp1_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	text_renderer = g_object_ref_sink (_tmp1_);
	g_object_set (text_renderer, "ellipsize-set", TRUE, NULL);
	g_object_set (text_renderer, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
	gtk_tree_view_insert_column_with_attributes (list_box, -1, "Clip content Selector", (GtkCellRenderer*) text_renderer, "text", 0, NULL);
	gtk_tree_view_set_headers_visible (list_box, FALSE);
	_tmp2_ = gtk_tree_view_get_selection (list_box);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_data1_->selection = _tmp3_;
	g_signal_connect_data (_data1_->selection, "changed", (GCallback) __lambda0__gtk_tree_selection_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_g_object_unref0 (text_renderer);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


void add_entry_to_list_box (GtkTreeView* list_box, const gchar* content) {
	GtkTreeIter iter = {0};
	gchar* _tmp0_ = NULL;
	gchar* cksum;
	gboolean _tmp1_;
	GtkTreeSelection* _tmp7_ = NULL;
	GtkTreeSelection* _tmp8_;
	GtkTreeSelection* selection;
	g_return_if_fail (list_box != NULL);
	g_return_if_fail (content != NULL);
	_tmp0_ = g_compute_checksum_for_string (G_CHECKSUM_SHA256, content, (gsize) (-1));
	cksum = _tmp0_;
	_tmp1_ = gee_abstract_map_has_key ((GeeAbstractMap*) content_table, cksum);
	if (_tmp1_) {
		gpointer _tmp2_ = NULL;
		GtkTreeIter* _tmp3_;
		_tmp2_ = gee_abstract_map_get ((GeeAbstractMap*) content_table, cksum);
		_tmp3_ = (GtkTreeIter*) _tmp2_;
		iter = *_tmp3_;
		_g_free0 (_tmp3_);
	} else {
		GtkTreeModel* _tmp4_ = NULL;
		GtkListStore* _tmp5_;
		GtkListStore* list_model;
		GtkTreeIter _tmp6_ = {0};
		_tmp4_ = gtk_tree_view_get_model (list_box);
		_tmp5_ = _g_object_ref0 (GTK_LIST_STORE (_tmp4_));
		list_model = _tmp5_;
		gtk_list_store_append (list_model, &_tmp6_);
		iter = _tmp6_;
		gtk_list_store_set (list_model, &iter, 0, content, -1);
		gee_abstract_map_set ((GeeAbstractMap*) content_table, cksum, &iter);
		new_insert = TRUE;
		_g_object_unref0 (list_model);
	}
	_tmp7_ = gtk_tree_view_get_selection (list_box);
	_tmp8_ = _g_object_ref0 (_tmp7_);
	selection = _tmp8_;
	gtk_tree_selection_select_iter (selection, &iter);
	gtk_widget_set_sensitive ((GtkWidget*) delete_button, TRUE);
	gtk_widget_set_sensitive ((GtkWidget*) delete_all_button, TRUE);
	_g_object_unref0 (selection);
	_g_free0 (cksum);
}


static gboolean _gtk_tree_iter_equal (const GtkTreeIter* s1, const GtkTreeIter* s2) {
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	if (s1->stamp != s2->stamp) {
		return FALSE;
	}
	if (s1->user_data != s2->user_data) {
		return FALSE;
	}
	if (s1->user_data2 != s2->user_data2) {
		return FALSE;
	}
	if (s1->user_data3 != s2->user_data3) {
		return FALSE;
	}
	return TRUE;
}


void delete_current_selection (GtkTreeView* list_box) {
	GtkTreeSelection* _tmp0_ = NULL;
	GtkTreeSelection* _tmp1_;
	GtkTreeSelection* selection;
	GtkTreeIter iter = {0};
	GtkTreeModel* model = NULL;
	GtkTreeModel* _tmp2_ = NULL;
	GtkTreeIter _tmp3_ = {0};
	gboolean _tmp4_;
	GtkTreeModel* _tmp5_;
	GtkTreeModel* _tmp15_ = NULL;
	GtkTreeIter _tmp16_ = {0};
	gboolean _tmp17_;
	GtkTreeModel* _tmp18_;
	g_return_if_fail (list_box != NULL);
	_tmp0_ = gtk_tree_view_get_selection (list_box);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	selection = _tmp1_;
	_tmp4_ = gtk_tree_selection_get_selected (selection, &_tmp2_, &_tmp3_);
	_g_object_unref0 (model);
	_tmp5_ = _g_object_ref0 (_tmp2_);
	model = _tmp5_;
	iter = _tmp3_;
	if (_tmp4_) {
		GeeMapIterator* _tmp6_ = NULL;
		GeeMapIterator* it;
		GtkListStore* _tmp7_;
		GtkListStore* list_model;
		gboolean _tmp8_;
		_tmp6_ = gee_abstract_map_map_iterator ((GeeAbstractMap*) content_table);
		it = _tmp6_;
		_tmp7_ = _g_object_ref0 (GTK_LIST_STORE (model));
		list_model = _tmp7_;
		_tmp8_ = gee_map_iterator_first (it);
		if (_tmp8_) {
			while (TRUE) {
				gboolean _tmp9_;
				gpointer _tmp10_ = NULL;
				GtkTreeIter* _tmp11_;
				gboolean _tmp12_;
				_tmp9_ = gee_map_iterator_has_next (it);
				if (!_tmp9_) {
					break;
				}
				_tmp10_ = gee_map_iterator_get_value (it);
				_tmp11_ = (GtkTreeIter*) _tmp10_;
				_tmp12_ = _gtk_tree_iter_equal (_tmp11_, &iter) == TRUE;
				_g_free0 (_tmp11_);
				if (_tmp12_) {
					gpointer _tmp13_ = NULL;
					gchar* _tmp14_;
					_tmp13_ = gee_map_iterator_get_key (it);
					_tmp14_ = (gchar*) _tmp13_;
					gee_abstract_map_unset ((GeeAbstractMap*) content_table, _tmp14_, NULL);
					_g_free0 (_tmp14_);
					break;
				}
				gee_map_iterator_next (it);
			}
		}
		gtk_tree_selection_unselect_iter (selection, &iter);
		gtk_list_store_remove (list_model, &iter);
		if (list_model->length == 0) {
			gtk_widget_set_sensitive ((GtkWidget*) delete_all_button, FALSE);
		}
		_g_object_unref0 (list_model);
		_g_object_unref0 (it);
	}
	_tmp17_ = gtk_tree_selection_get_selected (selection, &_tmp15_, &_tmp16_);
	_g_object_unref0 (model);
	_tmp18_ = _g_object_ref0 (_tmp15_);
	model = _tmp18_;
	iter = _tmp16_;
	if (!_tmp17_) {
		gtk_widget_set_sensitive ((GtkWidget*) delete_button, FALSE);
	}
	_g_object_unref0 (model);
	_g_object_unref0 (selection);
}


void delete_all_selection (GtkTreeView* list_box) {
	GtkTreeModel* _tmp0_ = NULL;
	GtkListStore* _tmp1_;
	GtkListStore* list_model;
	GtkTreeSelection* _tmp2_ = NULL;
	GtkTreeSelection* _tmp3_;
	GtkTreeSelection* selection;
	g_return_if_fail (list_box != NULL);
	_tmp0_ = gtk_tree_view_get_model (list_box);
	_tmp1_ = _g_object_ref0 (GTK_LIST_STORE (_tmp0_));
	list_model = _tmp1_;
	_tmp2_ = gtk_tree_view_get_selection (list_box);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	selection = _tmp3_;
	gtk_tree_selection_unselect_all (selection);
	gtk_list_store_clear (list_model);
	gee_abstract_map_clear ((GeeAbstractMap*) content_table);
	gtk_widget_set_sensitive ((GtkWidget*) delete_button, FALSE);
	gtk_widget_set_sensitive ((GtkWidget*) delete_all_button, FALSE);
	_g_object_unref0 (selection);
	_g_object_unref0 (list_model);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (Block2Data* _data2_) {
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_free0 (_data2_->content);
		_g_object_unref0 (_data2_->list_box);
		_g_object_unref0 (_data2_->list_view);
		g_slice_free (Block2Data, _data2_);
	}
}


static GtkTreeIter* _gtk_tree_iter_dup (GtkTreeIter* self) {
	GtkTreeIter* dup;
	dup = g_new0 (GtkTreeIter, 1);
	memcpy (dup, self, sizeof (GtkTreeIter));
	return dup;
}


static void _lambda1_ (Block2Data* _data2_) {
	delete_current_selection (_data2_->list_box);
}


static void __lambda1__gtk_button_released (GtkButton* _sender, gpointer self) {
	_lambda1_ (self);
}


static void _lambda2_ (Block2Data* _data2_) {
	delete_all_selection (_data2_->list_box);
}


static void __lambda2__gtk_button_released (GtkButton* _sender, gpointer self) {
	_lambda2_ (self);
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


static void _lambda3_ (GdkEvent* e, Block2Data* _data2_) {
	g_return_if_fail (e != NULL);
	if (!self_set) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = gtk_clipboard_wait_for_text (clip);
		_g_free0 (_data2_->content);
		_data2_->content = _tmp0_;
		add_entry_to_list_box (_data2_->list_box, _data2_->content);
	} else {
		self_set = FALSE;
	}
}


static void __lambda3__gtk_clipboard_owner_change (GtkClipboard* _sender, GdkEvent* p0, gpointer self) {
	_lambda3_ (p0, self);
}


static void _lambda4_ (GdkRectangle* rect, Block2Data* _data2_) {
	if (new_insert) {
		GtkAdjustment* _tmp0_ = NULL;
		GtkAdjustment* _tmp1_;
		GtkAdjustment* vadj;
		gdouble _tmp2_;
		gdouble _tmp3_;
		_tmp0_ = gtk_scrolled_window_get_vadjustment (_data2_->list_view);
		_tmp1_ = _g_object_ref0 (_tmp0_);
		vadj = _tmp1_;
		_tmp2_ = gtk_adjustment_get_upper (vadj);
		_tmp3_ = gtk_adjustment_get_page_size (vadj);
		gtk_adjustment_set_value (vadj, _tmp2_ - _tmp3_);
		_g_object_unref0 (vadj);
	}
	new_insert = FALSE;
}


static void __lambda4__gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self) {
	_lambda4_ (allocation, self);
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	Block2Data* _data2_;
	GeeHashMap* _tmp0_ = NULL;
	GtkWindow* _tmp1_ = NULL;
	GtkWindow* window;
	GtkHBox* _tmp2_ = NULL;
	GtkHBox* panel;
	GtkVBox* _tmp3_ = NULL;
	GtkVBox* vbox;
	GtkScrolledWindow* _tmp4_ = NULL;
	GtkTreeView* _tmp5_ = NULL;
	GtkButton* _tmp6_ = NULL;
	GtkButton* _tmp7_ = NULL;
	GtkClipboard* _tmp8_ = NULL;
	GtkClipboard* _tmp9_;
	gchar* _tmp10_ = NULL;
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	gtk_init (&args_length1, &args);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, GTK_TYPE_TREE_ITER, (GBoxedCopyFunc) _gtk_tree_iter_dup, g_free, NULL, NULL, NULL);
	_g_object_unref0 (content_table);
	content_table = _tmp0_;
	_tmp1_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	window = g_object_ref_sink (_tmp1_);
	_tmp2_ = (GtkHBox*) gtk_hbox_new (FALSE, 4);
	panel = g_object_ref_sink (_tmp2_);
	gtk_window_set_title (window, "Clipboard Selection Manager");
	_tmp3_ = (GtkVBox*) gtk_vbox_new (FALSE, 10);
	vbox = g_object_ref_sink (_tmp3_);
	_tmp4_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	_data2_->list_view = g_object_ref_sink (_tmp4_);
	gtk_scrolled_window_set_policy (_data2_->list_view, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (_data2_->list_view, GTK_SHADOW_ETCHED_IN);
	_tmp5_ = (GtkTreeView*) gtk_tree_view_new ();
	_data2_->list_box = g_object_ref_sink (_tmp5_);
	setup_list_box (_data2_->list_box);
	gtk_container_add ((GtkContainer*) _data2_->list_view, (GtkWidget*) _data2_->list_box);
	gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) _data2_->list_view, TRUE, TRUE, (guint) 0);
	_tmp6_ = (GtkButton*) gtk_button_new_with_label ("Delete");
	_g_object_unref0 (delete_button);
	delete_button = g_object_ref_sink (_tmp6_);
	g_signal_connect_data (delete_button, "released", (GCallback) __lambda1__gtk_button_released, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	_tmp7_ = (GtkButton*) gtk_button_new_with_label ("Delete All");
	_g_object_unref0 (delete_all_button);
	delete_all_button = g_object_ref_sink (_tmp7_);
	g_signal_connect_data (delete_all_button, "released", (GCallback) __lambda2__gtk_button_released, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	gtk_box_pack_start ((GtkBox*) panel, (GtkWidget*) delete_button, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) panel, (GtkWidget*) delete_all_button, FALSE, FALSE, (guint) 0);
	gtk_box_pack_end ((GtkBox*) vbox, (GtkWidget*) panel, FALSE, FALSE, (guint) 0);
	gtk_container_add ((GtkContainer*) window, (GtkWidget*) vbox);
	gtk_window_set_default_size (window, 200, 200);
	gtk_widget_show_all ((GtkWidget*) window);
	gtk_widget_set_sensitive ((GtkWidget*) delete_button, FALSE);
	gtk_widget_set_sensitive ((GtkWidget*) delete_all_button, FALSE);
	_tmp8_ = gtk_clipboard_get (GDK_SELECTION_PRIMARY);
	_tmp9_ = _g_object_ref0 (_tmp8_);
	_g_object_unref0 (clip);
	clip = _tmp9_;
	_tmp10_ = gtk_clipboard_wait_for_text (clip);
	_data2_->content = _tmp10_;
	if (_data2_->content != NULL) {
		add_entry_to_list_box (_data2_->list_box, _data2_->content);
	}
	g_signal_connect ((GtkObject*) window, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
	g_signal_connect_data (clip, "owner-change", (GCallback) __lambda3__gtk_clipboard_owner_change, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	g_signal_connect_data ((GtkWidget*) _data2_->list_box, "size-allocate", (GCallback) __lambda4__gtk_widget_size_allocate, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	gtk_main ();
	result = 0;
	_g_object_unref0 (vbox);
	_g_object_unref0 (panel);
	_g_object_unref0 (window);
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}



