/* gclip_select.c generated by valac 0.10.4, the Vala compiler
 * generated from gclip_select.vala, do not modify */

/*
    Copyright 2011 Li-Cheng (Andy) Tai

    gclip_select is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the Free
    Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    gclip_select is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along with
    gclip_select. If not, see http://www.gnu.org/licenses/.


*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block1Data Block1Data;
typedef struct _Block2Data Block2Data;

struct _Block1Data {
	int _ref_count_;
	GtkListStore* list_model;
	GtkTreeSelection* selection;
};

struct _Block2Data {
	int _ref_count_;
	GtkTreeView* list_box;
	char* content;
};


extern gboolean self_set;
gboolean self_set = FALSE;
extern GtkClipboard* clip;
GtkClipboard* clip = NULL;
extern GeeHashMap* content_table;
GeeHashMap* content_table = NULL;

void setup_list_box (GtkTreeView* list_box);
static void _lambda0_ (Block1Data* _data1_);
static void __lambda0__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
void add_entry_to_list_box (GtkTreeView* list_box, const char* content);
gint _vala_main (char** args, int args_length1);
static GtkTreeIter* _gtk_tree_iter_dup (GtkTreeIter* self);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
static void _lambda1_ (GdkEvent* e, Block2Data* _data2_);
static void __lambda1__gtk_clipboard_owner_change (GtkClipboard* _sender, GdkEvent* p0, gpointer self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (Block2Data* _data2_);



static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _lambda0_ (Block1Data* _data1_) {
	GtkTreeIter iter = {0};
	GtkTreeModel* model;
	char* content;
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_;
	model = NULL;
	content = NULL;
	gtk_tree_selection_get_selected (_data1_->selection, &_tmp0_, &iter);
	model = (_tmp1_ = _g_object_ref0 (_tmp0_), _g_object_unref0 (model), _tmp1_);
	gtk_tree_model_get ((GtkTreeModel*) _data1_->list_model, &iter, 0, &content, -1, -1);
	gtk_clipboard_set_text (clip, content, -1);
	self_set = TRUE;
	_g_free0 (content);
	_g_object_unref0 (model);
}


static void __lambda0__gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	_lambda0_ (self);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->selection);
		_g_object_unref0 (_data1_->list_model);
		g_slice_free (Block1Data, _data1_);
	}
}


void setup_list_box (GtkTreeView* list_box) {
	Block1Data* _data1_;
	GtkCellRendererText* _tmp0_;
	g_return_if_fail (list_box != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->list_model = gtk_list_store_new (1, G_TYPE_STRING);
	gtk_tree_view_set_rules_hint (list_box, TRUE);
	gtk_tree_view_set_model (list_box, (GtkTreeModel*) _data1_->list_model);
	gtk_tree_view_insert_column_with_attributes (list_box, -1, "Clip content Selector", (GtkCellRenderer*) (_tmp0_ = g_object_ref_sink ((GtkCellRendererText*) gtk_cell_renderer_text_new ())), "text", 0, NULL);
	_g_object_unref0 (_tmp0_);
	gtk_tree_view_set_headers_visible (list_box, FALSE);
	_data1_->selection = _g_object_ref0 (gtk_tree_view_get_selection (list_box));
	g_signal_connect_data (_data1_->selection, "changed", (GCallback) __lambda0__gtk_tree_selection_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	block1_data_unref (_data1_);
}


void add_entry_to_list_box (GtkTreeView* list_box, const char* content) {
	GtkTreeIter iter = {0};
	char* cksum;
	GtkTreeSelection* selection;
	g_return_if_fail (list_box != NULL);
	g_return_if_fail (content != NULL);
	cksum = g_compute_checksum_for_string (G_CHECKSUM_SHA256, content, -1);
	if (gee_abstract_map_has_key ((GeeAbstractMap*) content_table, cksum)) {
		GtkTreeIter* _tmp0_;
		iter = *(_tmp0_ = (GtkTreeIter*) gee_abstract_map_get ((GeeAbstractMap*) content_table, cksum));
		_g_free0 (_tmp0_);
	} else {
		GtkListStore* list_model;
		list_model = _g_object_ref0 (GTK_LIST_STORE (gtk_tree_view_get_model (list_box)));
		gtk_list_store_append (list_model, &iter);
		gtk_list_store_set (list_model, &iter, 0, content, -1);
		gee_abstract_map_set ((GeeAbstractMap*) content_table, cksum, &iter);
		_g_object_unref0 (list_model);
	}
	selection = _g_object_ref0 (gtk_tree_view_get_selection (list_box));
	gtk_tree_selection_select_iter (selection, &iter);
	_g_object_unref0 (selection);
	_g_free0 (cksum);
}


static GtkTreeIter* _gtk_tree_iter_dup (GtkTreeIter* self) {
	GtkTreeIter* dup;
	dup = g_new0 (GtkTreeIter, 1);
	memcpy (dup, self, sizeof (GtkTreeIter));
	return dup;
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


static void _lambda1_ (GdkEvent* e, Block2Data* _data2_) {
	g_return_if_fail (e != NULL);
	if (!self_set) {
		char* _tmp0_;
		_data2_->content = (_tmp0_ = g_strdup (gtk_clipboard_wait_for_text (clip)), _g_free0 (_data2_->content), _tmp0_);
		add_entry_to_list_box (_data2_->list_box, _data2_->content);
	} else {
		self_set = FALSE;
	}
}


static void __lambda1__gtk_clipboard_owner_change (GtkClipboard* _sender, GdkEvent* p0, gpointer self) {
	_lambda1_ (p0, self);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (Block2Data* _data2_) {
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_free0 (_data2_->content);
		_g_object_unref0 (_data2_->list_box);
		g_slice_free (Block2Data, _data2_);
	}
}


gint _vala_main (char** args, int args_length1) {
	gint result = 0;
	Block2Data* _data2_;
	GeeHashMap* _tmp0_;
	GtkWindow* window;
	GtkScrolledWindow* list_view;
	GtkClipboard* _tmp1_;
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	gtk_init (&args_length1, &args);
	content_table = (_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, GTK_TYPE_TREE_ITER, (GBoxedCopyFunc) _gtk_tree_iter_dup, g_free, NULL, NULL, NULL), _g_object_unref0 (content_table), _tmp0_);
	window = g_object_ref_sink ((GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL));
	gtk_window_set_title (window, "Clipboard Selection Manager");
	list_view = g_object_ref_sink ((GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL));
	gtk_scrolled_window_set_policy (list_view, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (list_view, GTK_SHADOW_ETCHED_IN);
	_data2_->list_box = g_object_ref_sink ((GtkTreeView*) gtk_tree_view_new ());
	setup_list_box (_data2_->list_box);
	gtk_container_add ((GtkContainer*) list_view, (GtkWidget*) _data2_->list_box);
	gtk_container_add ((GtkContainer*) window, (GtkWidget*) list_view);
	gtk_window_set_default_size (window, 200, 200);
	gtk_widget_show_all ((GtkWidget*) window);
	clip = (_tmp1_ = _g_object_ref0 (gtk_clipboard_get (GDK_SELECTION_PRIMARY)), _g_object_unref0 (clip), _tmp1_);
	_data2_->content = g_strdup (gtk_clipboard_wait_for_text (clip));
	if (_data2_->content != NULL) {
		add_entry_to_list_box (_data2_->list_box, _data2_->content);
	}
	g_signal_connect ((GtkObject*) window, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
	g_signal_connect_data (clip, "owner-change", (GCallback) __lambda1__gtk_clipboard_owner_change, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	gtk_main ();
	result = 0;
	_g_object_unref0 (list_view);
	_g_object_unref0 (window);
	block2_data_unref (_data2_);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}




